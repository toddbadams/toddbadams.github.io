<p>Only in trivial cases can a programmer just sit at a computer and start writing software. In order to create good software, not only an understanding of software is required, but also an understanding of the domain of the business solution is required. Think of the domain as the knowledge of the entire business in which the software operates. This approach to software development is known as <a href="http://en.wikipedia.org/wiki/Domain-driven_design" class="wikipeida" title="Domain driven design" target="_blank">Domain driven design</a>, is accomplished by making the software conform to the domain rather than making the domain conform the software.</p>
<p>It is the day-to-day web developer who understands all of the rules, issues, and needs of a modern CMS. The entire purpose of our CMS is to ease the job of the web developer in his/her efforts to build and support a website. In the article <a href="http://www.toddbadams.co.uk/cms-functionality" title="CMS Minimum Set of Functionality">&ldquo;<em>CMS Minimum Set of Functionality</em>&rdquo;</a> the functionality of the CMS is discussed, which is the start of understanding the domain of knowledge required for the software to be developed.</p>
<p>In the following articles <a href="http://en.wikipedia.org/wiki/Domain_model" title="Domain model" class="wikipedia" target="_blank">Domain models</a> are explored   to illustrate the vocabulary and key concepts of the CMS domain. The domain model separates the business logic from the properties of the model. While this creates extra work during the development process it allows for improved maintainability and flexibility. The separation of business logic from properties of the model means the domain models have no methods, just properties. This creates a simplified data-layer, without any verification steps. The data-layer simply creates, reads, updates, and deletes the domain models from the persistent data store. </p>
<p>The first step in creating a domain model is to build an <a href="http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming)" class="wikipedia" title="Abstraction principle (computer programming)" target="_blank">abstraction</a> of the domain, which is always incomplete, but evolves through continuous improvement. In our CMS, content can be of any type, articles, images, video, recipes, etc. Some of the content fits into the confines of a page and some does not. As an example, an article is, in essence, a page on a website. However, an image does not sit on a page by itself. Yes, an image can be displayed on a page, but its main purpose is to reside inside an article, which is on a page. Both the image and the article need to be stored in a persistent data store.</p>
<p>The article can be abstracted into a page, which in turn can be abstracted into a persistent data entity. The image can be abstracted into a non page that in turn can be abstracted into the persistent data entity. Each of these objects have properties. In the case of page content, it will have a title, author, and other properties that describe the page. The persistent data entity will have an identity so it can be found in the data store.</p>
<figure>
    <img src="http://www.toddbadams.co.uk/content/images/articles/domain-driven-design/page-domain-model.jpg" alt="page domain model">
    <figcaption>Page and non page domain models</figcaption>
</figure>
<p>What about the non page content? Are there any properties that are associated with all non page objects? As of now I cannot think of any, but I will leave the object in place for now, allowing properties to be added later in the design phase. Design is an iterative process after all.</p>
<p>Through the process of abstracting the domain, a language is developed to describe the domain. This language, known as ubiquitous language, is used to communicate to the project stakeholders an understanding of the problem at hand (our domain).</p>
<p>It is difficult, perhaps impossible to come up with a complete solution to our CMS, so instead I will formulate a core set of requirements and build an infrastructure that allows for continual improvement of the solution. This continual improvement takes its form of our plugin architecture. The negative side of this is that moving quickly leads to a solution that is not well thought out. Balance in design, and where to draw those lines is the art to any engineered solution.</p>
<p>I have not developed a CMS before and will be taking a road untraveled, making choices along the way. Speed to market is a priority, so decisions will be made and recorded. Later as the software evolves we will have a fuller understanding of which choices supported the project. Good design will accelerate the coding of project, and feedback from stakeholders will further improve the design.</p>
<h2>Next Steps</h2>
<p>Certain categories of domain objects include a specific identity; each identity is known as an entity in domain driven design. These objects are kept in a persistent data store, and it is the object’s identity that is used to interact with the data store. One of the CMS's content types is a <a href="http://en.wikipedia.org/wiki/URL" class="wikipedia" title="Uniform resource locator" target="_blank">URL</a>, which can be displayed as part of a page. These URLs need to be kept as part of the persistent data store and retrieved when required. Throughout the system the URL is referenced by its identity.</p>
<p>In the next step, we will look at developing entity models for the content of our CMS. Questions? Thoughts? Please add your opinion in the comments below.</p>
